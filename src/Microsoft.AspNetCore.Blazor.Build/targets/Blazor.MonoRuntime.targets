<Project>

  <Target
    Name="_BlazorCopyFilesToOutputDirectory"
    DependsOnTargets="BlazorBuild"
    Inputs="@(BlazorItemSpec)"
    Outputs="@(BlazorItemSpec->'%(TargetOutputPath)')"
    AfterTargets="CopyFilesToOutputDirectory">

    <!-- Copy the blazor output files  -->
    <Copy
      SourceFiles="@(BlazorItemSpec)"
      DestinationFiles="@(BlazorItemSpec->'%(TargetOutputPath)')"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
      Condition="'@(BlazorItemSpec)' != '' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
    </Copy>

    <!-- For statistics only. We want to print all the files in the
    dist folder at the end of the build. -->
    <ItemGroup>
      <BlazorOutputs Include="$(ProjectDir)$(OutputPath)dist/**/*" />
    </ItemGroup>

  </Target>

  <Target Name="_BlazorBuildReport"
          AfterTargets="_BlazorCopyFilesToOutputDirectory">

    <PropertyGroup>
      <BlazorBuildStatistics Condition="'$(BlazorBuildStatistics)' == ''">normal</BlazorBuildStatistics>
      <BlazorBuildStatistics Condition="'$(BlazorBuildStatistics)' == 'true'">high</BlazorBuildStatistics>
    </PropertyGroup>

    <Message Importance="high" Text="Blazor Build result -> @(BlazorOutputs->Distinct()->Count()) files in $(ProjectDir)$(OutputPath)dist" />
    <Message Importance="$(BlazorBuildStatistics)" Text="%(BlazorOutputs.Identity)" />
  </Target>

  <PropertyGroup>
    <BlazorBuildDependsOn>
      GetBlazorBuildConfiguration;
      ResolveBinaryOutput;
      BuildBlazorIndexHtml;
    </BlazorBuildDependsOn>
  </PropertyGroup>

  <Target Name="BlazorBuild" DependsOnTargets="$(BlazorBuildDependsOn)" AfterTargets="Compile" />

  <Target Name="CollectOutputsFromPreviousRun">
    <!-- Incremental builds 
  The process for doing builds goes as follows:
  Collect all the inputs from previous runs:
  1) Intermediate Assembly.
  2) Assembly references.
  3) Linker Descriptors/Options (if linking is on).

  Produce a hash file with the Hash SDK task and write that hash to a marker file only when different than
  the existing.

  Use the marker as an input to the rest of the pipeline:
  1) To Run Linker if the linker is on.
  2) To GetBaseClassLibrary if the linker is off.

  We will copy all the static content (wasm ,asmjs, blazorjs) into the dist/_framework folder in 
  /bin/<<configuration>>/<<targetframework>>.

  When we have to copy the binaries for the application we will have two choices:
  If the application was linked we will have to collect the previous outputs (linked assemblies + markers) and the
  previous inputs (linker descriptors + referenced assemblies + intermediate assembly).
  If the application was not linked, we will have to collect the previous outputs (resolved reference assemblies copied to output) and
  the previous inputs (list of application references + intermediate assembly).
  
  Once we've chosen what to collect, we will have to produce a hash with the contents of the inputs
  that we will use as a marker to indicate other tasks further down in the pipeline if any input they require
  has changed.
  -->
  </Target>

  <Target Name="GetBlazorBuildConfiguration">
    <!-- 
    This task produces all the "final" paths for all the files we need to produce the final output.
    
    The final folder is something like bin/<<Configuration>>/<<TargetFramework>>/dist
    /_framework/_bin <- This will contain either the BCL + app assemblies or the result of linking the app.
    /_framework/asmjs <- This will contain the asmjs runtime copied from the nuget package.
    /_framework/wasm <- This will contain the wsm runtime copied from the nuget package.
    /_framework/blazor.js <- This is the blazor.js file copied from the nuget package.
    /index.html <- This is the optional index.html file generated from wwwroot/Index.html in case it's present. It
    will be canonicalized to index.html
    
    This task also defines some intermediate paths that we will use:
    /obj/debug/netstandard2.0/blazor/blazor/linker <- This will be used to create the output from the linker.
    /obj/debug/netstandard2.0/blazor/blazor/linker.marker.txt <- This will be used to save the output files from
    the linker and use that as marker to identify whether or not we need to run the linker.
    /obj/debug/netstandard2.0/blazor/blazor/linker.descriptor.xml <- This will be used to generate an XML descriptor
    for the mono linker.
    -->

    <PropertyGroup Label="Build properties">
      <BlazorShouldRunMonoLinker>$(BlazorLinkOnBuild)</BlazorShouldRunMonoLinker>
    </PropertyGroup>

    <PropertyGroup Label="Blazor HTML inputs">
      <BlazorWebRootPath>$(ProjectDir)$(BlazorWebRootName)</BlazorWebRootPath>
      <BlazorIndexHtml>$(BlazorWebRootPath)$(BlazorIndexHtmlName)</BlazorIndexHtml>
    </PropertyGroup>

    <ItemGroup Label="BlazorItemSpecs">
      <BlazorItemSpec Include="@(MonoAsmjsFile)">
        <TargetOutputPath>$(ProjectDir)$(OutputPath)$(BaseBlazorRuntimeAsmjsOutputPath)%(FileName)%(Extension)</TargetOutputPath>
        <Type>AsmJs</Type>
        <IsStatic>true</IsStatic>
      </BlazorItemSpec>
      <BlazorItemSpec Include="@(MonoWasmFile)">
        <TargetOutputPath>$(ProjectDir)$(OutputPath)$(BaseBlazorRuntimeWasmOutputPath)%(FileName)%(Extension)</TargetOutputPath>
        <Type>WebAssembly</Type>
        <IsStatic>true</IsStatic>
      </BlazorItemSpec>
      <BlazorItemSpec Include="@(BlazorJsFile)">
        <TargetOutputPath>$(ProjectDir)$(OutputPath)$(BaseBlazorJsOutputPath)%(FileName)%(Extension)</TargetOutputPath>
        <Type>BlazorRuntime</Type>
        <IsStatic>true</IsStatic>
      </BlazorItemSpec>
    </ItemGroup>

    <PropertyGroup Label="Intermediate output paths">

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor -->
      <BlazorIntermediateOutputPath>$(ProjectDir)$(IntermediateOutputPath)$(BaseBlazorIntermediateOutputPath)</BlazorIntermediateOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker/ -->
      <BlazorIntermediateLinkerOutputPath>$(BlazorIntermediateOutputPath)linker/</BlazorIntermediateLinkerOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/resolvedassemblies/ -->
      <BlazorIntermediateResolvedAssembliesOutputPath>$(BlazorIntermediateOutputPath)resolvedassemblies/</BlazorIntermediateResolvedAssembliesOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker.marker.txt -->
      <BlazorIntermediateLinkerResultFilePath>$(BlazorIntermediateOutputPath)linker.marker.txt</BlazorIntermediateLinkerResultFilePath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/index.html -->
      <BlazorIndexHtmlOutputPath>$(BlazorIntermediateOutputPath)$(BlazorOutputIndexHtmlName)</BlazorIndexHtmlOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker.descriptor.xml -->
      <GeneratedBlazorLinkerDescriptor>$(BlazorIntermediateOutputPath)linker.descriptor.xml</GeneratedBlazorLinkerDescriptor>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/resolved.assemblies.txt -->
      <BlazorResolvedAssembliesOutputPath>$(BlazorIntermediateOutputPath)resolved.assemblies.txt</BlazorResolvedAssembliesOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/inputs.basic.cache -->
      <BlazorBuildCommonInputsCache>$(BlazorIntermediateOutputPath)inputs.basic.cache</BlazorBuildCommonInputsCache>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/inputs.basic.cache -->
      <BlazorBuildLinkerSwitchInputsCache>$(BlazorIntermediateOutputPath)inputs.linkerswitch.cache</BlazorBuildLinkerSwitchInputsCache>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/inputs.linker.cache -->
      <BlazorBuildLinkerInputsCache>$(BlazorIntermediateOutputPath)inputs.linker.cache</BlazorBuildLinkerInputsCache>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/inputs.index.cache -->
      <BlazorBuildIndexInputsCache>$(BlazorIntermediateOutputPath)inputs.index.cache</BlazorBuildIndexInputsCache>

    </PropertyGroup>

    <PropertyGroup Label="Final output paths">
      <BlazorRuntimeBinOutputPath>$(ProjectDir)$(OutputPath)$(BaseBlazorRuntimeBinOutputPath)</BlazorRuntimeBinOutputPath>
    </PropertyGroup>

    <MakeDir Directories="$(BlazorIntermediateOutputPath)" />

  </Target>

  <Target Name="DefineBlazorBasicInputs">
    <ItemGroup>
      <BlazorBuildInput Include="@(IntermediateAssembly)" />
      <BlazorBuildInput Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll'))" />
      <BlazorBuildInput Include="$(BlazorShouldRunMonoLinker)" />
    </ItemGroup>

    <Hash ItemsToHash="@(BlazorBuildInput)">
      <Output TaskParameter="HashResult" PropertyName="_BlazorBuildBasicInputHash" />
    </Hash>

    <WriteLinesToFile
      Lines="$(_BlazorBuildBasicInputHash)"
      File="$(BlazorBuildCommonInputsCache)"
      Overwrite="True"
      WriteOnlyWhenDifferent="True" />

    <!-- Switch to detect when we switch from linking to not linking and viceversa -->
    <WriteLinesToFile
      Lines="$(BlazorShouldRunMonoLinker)"
      File="$(BlazorBuildLinkerSwitchInputsCache)"
      Overwrite="True"
      WriteOnlyWhenDifferent="True" />

    <ItemGroup>
      <FileWrites Include="$(BlazorBuildLinkerSwitchInputsCache)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(BlazorBuildCommonInputsCache)" />
    </ItemGroup>

  </Target>

  <Target Name="GenerateLinkerDescriptors"
          DependsOnTargets="DefineBlazorBasicInputs"
          Inputs="$(BlazorBuildCommonInputsCache)"
          Outputs="$(GeneratedBlazorLinkerDescriptor)"
          Condition="$(BlazorShouldRunMonoLinker) == 'true' and '@(BlazorLinkerDescriptor)' == ''">

    <ItemGroup>
      <PrepareAssemblyLine Include="@(IntermediateAssembly->'%(FileName)')" />
      <GeneratedDescriptorLine Include="&lt;linker&gt;" />
      <GeneratedDescriptorLine Include="@(PrepareAssemblyLine->'&lt;assembly fullname=&quot;%(Identity)&quot; /&gt;')" />
      <GeneratedDescriptorLine Include="&lt;/linker&gt;" />
    </ItemGroup>

    <WriteLinesToFile
      Lines = "@(GeneratedDescriptorLine)"
      File ="$(GeneratedBlazorLinkerDescriptor)"
      Overwrite="true"
      WriteOnlyWhenDifferent="True" />

  </Target>

  <Target Name="CollectLinkerDescriptors" DependsOnTargets="GenerateLinkerDescriptors">

    <ItemGroup Condition="@(BlazorLinkerDescriptor) == ''">
      <BlazorLinkerDescriptor Include="$(GeneratedBlazorLinkerDescriptor)" />
      <FileWrites Include="$(GeneratedBlazorLinkerDescriptor)" />
    </ItemGroup>

    <ItemGroup>
      <BlazorLinkerBuildInput Include="@(IntermediateAssembly)" />
      <BlazorLinkerBuildInput Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll'))" />
      <BlazorLinkerBuildInput Include="@(BlazorLinkerDescriptor)" />
      <BlazorLinkerBuildInput Include="$(AdditionalLinkerOptions)" />
    </ItemGroup>

    <Hash ItemsToHash="@(BlazorLinkerBuildInput)">
      <Output TaskParameter="HashResult" PropertyName="_BlazorBuildLinkerInputHash" />
    </Hash>

    <WriteLinesToFile
      Lines="$(_BlazorBuildLinkerInputHash)"
      File="$(BlazorBuildLinkerInputsCache)"
      Overwrite="True"
      WriteOnlyWhenDifferent="True" />
  </Target>

  <Target Name="ResolveBinaryOutput" DependsOnTargets="CollectLinkerOutputs;GetBaseClassLibrary" />

  <Target
    Name="RunMonoLinker"
    Condition="$(BlazorShouldRunMonoLinker) == 'true'"
    DependsOnTargets="CollectLinkerDescriptors"
    Inputs="$(BlazorBuildLinkerInputsCache)"
    Outputs="$(BlazorIntermediateLinkerResultFilePath)"
  >
    <!-- 
    At this point we have decided to run the mono linker on the Blazor assembly and its dependencies.
    The steps to run the mono linker are the following:
    1) Clear the linker output directory if not clean before hand, as we don't know what the outputs of
    the linker will be.
    2) Run the linker on the main assembly, its dependencies and pass in the BCL folders to do the lookup
    for framework assemblies.
    3) Once we've run the linker we need to capture the produced output and generate a marker file containing
    the list of produced files. This file will act as a marker to skip running the linker if nothing changed.
    4) Add the file we just created to the list of file writes, so that if we turn off the linker or do something
    else we'll know we have to run the linker again.
    -->
    <ItemGroup>
      <_BlazorAssembliesToLink Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll')->'-a &quot;%(FullPath)&quot;')" />
      <_BlazorAssembliesToLink Include="@(IntermediateAssembly->'-a &quot;%(FullPath)&quot;')" />
      <_BlazorFolderLookupPaths Include="@(MonoBaseClassLibraryFolder->'-d &quot;%(Identity)&quot;')" />
      <_BlazorAssemblyDescriptorFiles
        Include="@(BlazorLinkerDescriptor->'-x &quot;%(FullPath)&quot;')" Condition="'@(BlazorLinkerDescriptor)' != ''" />
    </ItemGroup>

    <PropertyGroup>
      <_BlazorMonoLinkerAdditionalOptions>$(AdditionalMonoLinkerOptions)</_BlazorMonoLinkerAdditionalOptions>
    </PropertyGroup>

    <!-- Clear the contents of /obj/debug/netstandard2.0/blazor/blazor/linker -->
    <Delete Files="$(BlazorIntermediateLinkerOutputPath)*.dll" />

    <!-- Run the linker and put the results in /obj/debug/netstandard2.0/blazor/blazor/linker -->
    <Exec Command="dotnet $(MonoLinkerPath) $(_BlazorMonoLinkerAdditionalOptions) @(_BlazorFolderLookupPaths, ' ') -o $(BlazorIntermediateLinkerOutputPath) @(_BlazorAssemblyDescriptorFiles, ' ') @(_BlazorAssembliesToLink, ' ')"  />

    <!-- Collect the contents of /obj/debug/netstandard2.0/blazor/blazor/linker/ -->
    <ItemGroup>
      <_BlazorLinkerOutput Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
    </ItemGroup>

    <!-- 
    Write the list of files in /obj/debug/netstandard2.0/blazor/blazor/linker/ into 
    /obj/debug/netstandard2.0/blazor/blazor/linker.marker.txt
    -->
    <WriteLinesToFile
      File="$(BlazorIntermediateLinkerResultFilePath)"
      Lines="@(_BlazorLinkerOutput)"
      Overwrite="true" />

    <!-- Add /obj/debug/netstandard2.0/blazor/blazor/linker.marker.txt to the list of written files. -->
    <ItemGroup>
      <FileWrites Include="$(BlazorIntermediateLinkerResultFilePath)" />
    </ItemGroup>
  </Target>

  <Target
    Name="CollectLinkerOutputs"
    Condition="'$(BlazorShouldRunMonoLinker)' == 'true'"
    DependsOnTargets="RunMonoLinker">
    <!--
    Read the outputs from the linker (from this run or a previous run) and set them in an item group for
    later use.
    -->
    <ReadLinesFromFile File="$(BlazorIntermediateLinkerResultFilePath)">
      <Output TaskParameter="Lines" ItemName="_OptimizedFiles"/>
    </ReadLinesFromFile>

    <ItemGroup>
      <BlazorItemSpec Include="@(_OptimizedFiles)">
        <TargetOutputPath>$(BlazorRuntimeBinOutputPath)%(FileName)%(Extension)</TargetOutputPath>
        <Type>Assembly</Type>
        <PrimaryOutput Condition="'%(FileName)' == @(IntermediateAssembly->'%(FileName)')">true</PrimaryOutput>
      </BlazorItemSpec>
      <FileWrites Include="@(BlazorItemSpec->WithMetadataValue('Type','Assembly')->'%(TargetOutputPath)')" />
    </ItemGroup>

  </Target>

  <Target
    Name="ResolveRuntimeDependencies"
    Condition="'$(BlazorShouldRunMonoLinker)' == 'false'"
    DependsOnTargets="DefineBlazorBasicInputs"
    Inputs="$(BlazorBuildCommonInputsCache)"
    Outputs="$(BlazorResolvedAssembliesOutputPath)"
  >
    <ItemGroup>
      <_DependenciesParameter Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll')->'--reference &quot;%(FullPath)&quot;')" />
    </ItemGroup>
    <PropertyGroup>
      <_BclParameter>--base-class-library &quot;$(MonoBaseClassLibraryPath)&quot; --base-class-library &quot;$(MonoBaseClassLibraryFacadesPath)&quot;</_BclParameter>
    </PropertyGroup>

    <Exec Command="$(BlazorBuildExe) resolve-dependencies &quot;@(IntermediateAssembly->'%(FullPath)')&quot; @(_DependenciesParameter, ' ') $(_BclParameter) --output &quot;$(BlazorResolvedAssembliesOutputPath)&quot;" />

  </Target>

  <Target
    Name="ReadResolvedRuntimeDependencies"
    DependsOnTargets="ResolveRuntimeDependencies">

    <ReadLinesFromFile File="$(BlazorResolvedAssembliesOutputPath)">
      <Output TaskParameter="Lines" ItemName="BlazorResolvedRuntimeDependencies"/>
    </ReadLinesFromFile>
    
    <ItemGroup>
      <IntermediateResolvedRuntimeDependencies Include="@(BlazorResolvedRuntimeDependencies->'$(BlazorIntermediateResolvedAssembliesOutputPath)%(FileName)%(Extension)')" />
    </ItemGroup>

  </Target>

  <Target
    Name="CopyResolvedAssemblies"
    Inputs="@(BlazorResolvedRuntimeDependencies)"
    Outputs="@(BlazorResolvedRuntimeDependencies->'$(BlazorIntermediateResolvedAssembliesOutputPath)%(FileName)%(Extension)')"
    DependsOnTargets="ReadResolvedRuntimeDependencies">

    <Copy
      SourceFiles="@(BlazorResolvedRuntimeDependencies)"
      DestinationFiles="@(BlazorResolvedRuntimeDependencies->'$(BlazorIntermediateResolvedAssembliesOutputPath)%(FileName)%(Extension)')"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)">

    </Copy>
    
    <ItemGroup>
      <FileWrites Include="@(IntermediateResolvedRuntimeDependencies)" />
    </ItemGroup>

  </Target>

  <Target
    Name="TouchResolvedAssemblies"
    DependsOnTargets="CopyResolvedAssemblies"
    Inputs="$(BlazorBuildLinkerSwitchInputsCache)"
    Outputs="@(IntermediateResolvedRuntimeDependencies)"
  >

    <Touch Files="@(IntermediateResolvedRuntimeDependencies)" ForceTouch="true" />

  </Target>

  <Target
    Name="GetBaseClassLibrary"
    DependsOnTargets="ResolveRuntimeDependencies;ReadResolvedRuntimeDependencies;CopyResolvedAssemblies;TouchResolvedAssemblies"
    Condition="'$(BlazorShouldRunMonoLinker)' == 'false'">

    <!--
    At this point we have decided not to run the linker and instead to just copy the assemblies
    from the BCL referenced by the app the nuget package into the _framework/_bin folder.
    The only thing we need to do here is collect the list of items that will go into _framework/_bin.
    -->

    <ItemGroup>
      <BlazorItemSpec Include="@(IntermediateResolvedRuntimeDependencies)">
        <TargetOutputPath>$(BlazorRuntimeBinOutputPath)%(FileName)%(Extension)</TargetOutputPath>
        <Type>Assembly</Type>
        <PrimaryOutput Condition="'%(FileName)' == @(IntermediateAssembly->'%(FileName)')">true</PrimaryOutput>
      </BlazorItemSpec>
      <FileWrites Include="@(BlazorItemSpec->WithMetadataValue('Type','Assembly')->'%(TargetOutputPath)')" />
    </ItemGroup>

  </Target>

  <Target Name="ResolveIndexHtmlInputs">
    <ItemGroup>
      <BlazorIndexHtmlInput Include="$(BlazorIndexHtml)" />
      <BlazorIndexHtmlInput Include="@(BlazorItemSpec->WithMetadataValue('Type','Assembly')->'%(FullPath)')" />
    </ItemGroup>

    <WriteLinesToFile
      File="$(BlazorBuildIndexInputsCache)"
      Lines="@(BlazorIndexHtmlInput)"
      Overwrite="true"
      WriteOnlyWhenDifferent="True" />

  </Target>

  <Target
    Name="BuildBlazorIndexHtml"
    DependsOnTargets="ResolveIndexHtmlInputs"
    Inputs="$(BlazorBuildIndexInputsCache)"
    Outputs="$(BlazorIndexHtmlOutputPath)">
    <ItemGroup>
      <_AppReferences Include="@(BlazorItemSpec->WithMetadataValue('Type','Assembly')->WithMetadataValue('PrimaryOutput','')->'%(FileName)%(Extension)')" />
    </ItemGroup>

    <Exec Command="$(BlazorBuildExe) build @(IntermediateAssembly) -hp &quot;$(BlazorIndexHtml)&quot; @(_AppReferences->'-r %(Identity)', ' ') -o &quot;$(BlazorIndexHtmlOutputPath)&quot;" />

    <ItemGroup Condition="Exists('$(BlazorIndexHtmlOutputPath)')">
      <_BlazorIndex Include="$(BlazorIndexHtmlOutputPath)" />
      <BlazorItemSpec Include="@(_BlazorIndex)">
        <TargetOutputPath>$(ProjectDir)$(OutputPath)dist/%(FileName)%(Extension)</TargetOutputPath>
        <Type>EntryPoint</Type>
      </BlazorItemSpec>
      <FileWrites Include="$(BlazorIndexHtmlOutputPath)" />
    </ItemGroup>

  </Target>

</Project>